<p>Windows programs are gross in comparison to the simplicity and straight forward functionality of Unix alternatives. Why is that?</p>

<p>
    Let me introduce the two concepts:
    <ul>
        <li>Natural programs</li>
        <li>Unnatural programs</li>
    </ul>
</p>

<h2>Natural programs</h2>
<p>Natural programs are made by a series of conversions that produce a straight forward outcome without unneeded complexity or frills. The typical order of operations go from Binary to Decimal, Decimal to Hexadecimal, and finally Hexadecimal to ASCII.</p>

<p>Natural programs are stable and are defined by that. Natural programming can be seem in those that follow the Unix philosophy. These types are always the most straight forward, and never sway from their original intent.</p>

<p>The good ones manipulate text (the most powerful resource) and prioritize power over so-called "ease-of-use" ("ease-of-use" really means "you don't have to learn but will be severely inhibited by this trade-off"), and the best of 'em are CLI/TUI-based only.</p>

<p>
    Real world examples of natural programs:
    <ul>
        <li>awk</li>
        <li>feh</li>
        <li>grep</li>
        <li>mpd</li>
        <li>mpv</li>
        <li>newsboat</li>
        <li>sed</li>
        <li>vi(m) (one of the best examples)</li>
    </ul>
</p>

<h2>Unnatural programs</h2>
<p>Unnatural programs are foundationally (as in house foundation) the same as their natural counterpart. The real issue is what comes after it. Their way is the same thing, but with subjectively "pretty" packaging and everything in excess. The core functionality is there, like being a program that edits text (text editor), but is vastly more "bloated". The outcome is the same, but the manner in which it operates is not.</p>

<p>There are a whole bunch of reasons as to why this is bad:</p>

<p><b>Attack surface</b>: This "bloat" creates a larger attack service, and therefore the potential for more code/performance related issues in the case of a fowl programmatic interaction.</p>

<p><b>Just because you can doesn't mean you should</b>: I go into this in my other article about <a href="../computing/the_fallacy_of_program_ease.php">The Fallacy of Program Ease</a>. To sum it up: Just because you can do something, doesn't mean you should. Just because you can draw animations for each, tiny, insignificant action, doesn't mean you should (it's bad, and legitimately has no value to learning/memory retention/muscle memory).</p>

<p>This is unnatural computing.</p>

<p>
    Real world examples of unnatural programs:
    <ul>
        <li>Emacs (Emacs is alright, it's just bloated and laggy shit)</li>
        <li>VSCode (sorry VSCode, same reason as Emacs)</li>
    </ul>
</p>

<p>Windows programs are gross for this simple reason: Most are key examples of unnatural computing. Most do not follow the docrine by the original Unix philosophers (Ken Thompson, Dennis Ritchie, and others).</p>
